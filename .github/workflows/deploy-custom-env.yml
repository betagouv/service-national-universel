name: Build and deploy custom environment

on:
  workflow_dispatch:
  pull_request:
    branches:
      - main

jobs:
  prepare:
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'pull_request' &&
        (contains(github.head_ref, '-ci-') ||
        startsWith(github.head_ref, 'ci-') ||
        endsWith(github.head_ref, '-ci') ||
        contains(github.head_ref, '_ci_') ||
        startsWith(github.head_ref, 'ci_') ||
        endsWith(github.head_ref, '_ci'))
      )
    runs-on: ubuntu-latest
    outputs:
      branch_name: ${{ steps.check.outputs.branch_name }}
      env_name: ${{ steps.env_name.outputs.env_name }}

    steps:
      - name: Check branch name
        id: check
        run: |
          if [[ ${{ github.event_name }} == 'pull_request' ]] ; then
            branch_name=${{ github.head_ref }}
          else
            branch_name=${{ github.ref_name }}
          fi
          if [[ $branch_name == 'main' ]] || [[ $branch_name == 'production' ]] ; then
            echo "This action is not available on the branch $branch_name"
            exit 1
          fi
          echo "branch_name=$branch_name" >> $GITHUB_OUTPUT

      - uses: actions/checkout@v4
        with:
          ref: ${{ steps.check.outputs.branch_name }}

      - name: Get custom-env name
        id: env_name
        uses: ./.github/actions/get_custom_env_name
        with:
          branch_name: ${{ steps.check.outputs.branch_name }}

  build_api:
    needs: prepare
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.image_tag.outputs.image_tag }}
    env:
      app_name: api

    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare.outputs.branch_name }}
          fetch-depth: 0

      - name: Debug
        run: |
          git log -- ${{env.app_name}} packages

      - name: Get last modified commit sha
        id: commit_sha
        run: |
          commit_sha=$(git log --max-count=1 --oneline -- ${{env.app_name}} packages | cut -d " " -f 1)
          echo $commit_sha
          echo "commit_sha=$commit_sha" >> $GITHUB_OUTPUT

      - name: Get image tag
        id: image_tag
        uses: ./.github/actions/get_image_tag
        with:
          sha: ${{ steps.commit_sha.outputs.commit_sha }}

      - name: Check if image exists
        id: check
        uses: ./.github/actions/check_docker_image_tag
        with:
          registry: ${{ secrets.SCW_CI_IMAGE_REGISTRY }}
          image_name: ${{env.app_name}}
          image_tag: ${{ steps.image_tag.outputs.image_tag }}
          secret_key: ${{ secrets.SCW_CI_DEPLOY_SECRET_KEY }}

      - name: Break
        run: exit 1

      - name: Docker Build & Publish
        uses: ./.github/actions/build_docker_image
        if: steps.check.outputs.tag_exists == 0
        with:
          username: nologin
          password: ${{ secrets.SCW_CI_DEPLOY_SECRET_KEY }}
          registry: ${{ secrets.SCW_CI_IMAGE_REGISTRY }}
          image_name: ${{env.app_name}}
          dockerfile_path: ${{env.app_name}}/Dockerfile
          image_tag: ${{ steps.image_tag.outputs.image_tag }}


  build_app:
    needs: prepare
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.image_tag.outputs.image_tag }}
    env:
      app_name: app

    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare.outputs.branch_name }}
          fetch-depth: 0

      - name: Debug
        run: |
          git log -- ${{env.app_name}} packages

      - name: Get last modified commit sha
        id: commit_sha
        run: |
          commit_sha=$(git log --max-count=1 --oneline -- ${{env.app_name}} packages | cut -d " " -f 1)
          echo $commit_sha
          echo "commit_sha=$commit_sha" >> $GITHUB_OUTPUT

      - name: Get image tag
        id: image_tag
        uses: ./.github/actions/get_image_tag
        with:
          sha: ${{ steps.commit_sha.outputs.commit_sha }}

      - name: Check if image exists
        id: check
        uses: ./.github/actions/check_docker_image_tag
        with:
          registry: ${{ secrets.SCW_CI_IMAGE_REGISTRY }}
          image_name: ${{env.app_name}}
          image_tag: ${{ steps.image_tag.outputs.image_tag }}
          secret_key: ${{ secrets.SCW_CI_DEPLOY_SECRET_KEY }}

      - name: Break
        run: exit 1

      - name: Docker Build & Publish
        uses: ./.github/actions/build_docker_image
        if: steps.check.outputs.tag_exists == 0
        with:
          username: nologin
          password: ${{ secrets.SCW_CI_DEPLOY_SECRET_KEY }}
          registry: ${{ secrets.SCW_CI_IMAGE_REGISTRY }}
          image_name: ${{env.app_name}}
          dockerfile_path: ${{env.app_name}}/Dockerfile
          image_tag: ${{ steps.image_tag.outputs.image_tag }}


  build_admin:
    needs: prepare
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.image_tag.outputs.image_tag }}
    env:
      app_name: admin

    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare.outputs.branch_name }}
          fetch-depth: 0


      - name: Debug
        run: |
          git log -- ${{env.app_name}} packages

      - name: Get last modified commit sha
        id: commit_sha
        run: |
          commit_sha=$(git log --max-count=1 --oneline -- ${{env.app_name}} packages | cut -d " " -f 1)
          echo $commit_sha
          echo "commit_sha=$commit_sha" >> $GITHUB_OUTPUT

      - name: Get image tag
        id: image_tag
        uses: ./.github/actions/get_image_tag
        with:
          sha: ${{ steps.commit_sha.outputs.commit_sha }}

      - name: Check if image exists
        id: check
        uses: ./.github/actions/check_docker_image_tag
        with:
          registry: ${{ secrets.SCW_CI_IMAGE_REGISTRY }}
          image_name: ${{env.app_name}}
          image_tag: ${{ steps.image_tag.outputs.image_tag }}
          secret_key: ${{ secrets.SCW_CI_DEPLOY_SECRET_KEY }}

      - name: Break
        run: exit 1

      - name: Docker Build & Publish
        uses: ./.github/actions/build_docker_image
        if: steps.check.outputs.tag_exists == 0
        with:
          username: nologin
          password: ${{ secrets.SCW_CI_DEPLOY_SECRET_KEY }}
          registry: ${{ secrets.SCW_CI_IMAGE_REGISTRY }}
          image_name: ${{env.app_name}}
          dockerfile_path: ${{env.app_name}}/Dockerfile
          image_tag: ${{ steps.image_tag.outputs.image_tag }}

  deploy:
    runs-on: ubuntu-latest
    needs: [prepare, build_api, build_admin, build_app]
    concurrency:
      group: ${{ github.workflow }}-${{ github.head_ref || github.ref_name }}
      cancel-in-progress: false
    env:
      SCW_ACCESS_KEY: ${{ secrets.SCW_CI_DEPLOY_ACCESS_KEY }}
      SCW_SECRET_KEY: ${{ secrets.SCW_CI_DEPLOY_SECRET_KEY }}
      PG_CONN_STR: ${{ secrets.SCW_CI_BACKEND_CONN_STR }}
      PGUSER: ${{ secrets.SCW_CI_BACKEND_USER }}
      PGPASSWORD: ${{ secrets.SCW_CI_BACKEND_PASSWORD }}
      custom_directory: ./terraform/environments/ci/custom
      scw_endpoint: "https://api.scaleway.com/secret-manager/v1alpha1"

    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare.outputs.branch_name }}

      - uses: hashicorp/setup-terraform@v3

      - name: Create custom env stack
        working-directory: ${{ env.custom_directory }}
        run: sed -i.bak "s|###___ENV_NAME___###|${{ needs.prepare.outputs.env_name }}|g" main.tf
        # the -i option replaces main.tf in-place creating a .bak backup file

      - name: Init terraform
        working-directory: ${{ env.custom_directory }}
        run: terraform init

      - name: Check if secret exists
        id: check_secret
        working-directory: ${{ env.custom_directory }}
        run: |
          if terraform state show 'scaleway_secret.custom' ; then
              echo "has_secret=1" >> $GITHUB_OUTPUT
          else
              echo "has_secret=0" >> $GITHUB_OUTPUT
          fi

      - name: Get CI project & secret ID
        id: ci_outputs
        if: steps.check_secret.outputs.has_secret == '0'
        working-directory: "${{ env.custom_directory }}/../"
        run: |
          terraform init
          long_secret_id=$(terraform output -raw secret_id)
          region=$(cut -d "/" -f 1 <<< $long_secret_id)
          secret_id=$(cut -d "/" -f 2 <<< $long_secret_id)
          project_id=$(terraform output -raw project_id)
          echo "secret_id=$secret_id" >> $GITHUB_OUTPUT
          echo "project_id=$project_id" >> $GITHUB_OUTPUT
          echo "region=$region" >> $GITHUB_OUTPUT
          echo "Project ID: $project_id - Secret ID: $secret_id"

      - name: Create secret
        id: create_secret
        if: steps.check_secret.outputs.has_secret == '0'
        working-directory: ${{ env.custom_directory }}
        run: |
          echo "Create secret for custom environment"
          secret_id=$(curl -s -X POST \
            -H "X-Auth-Token: $SCW_SECRET_KEY" \
            -H "Content-Type: application/json" \
            -d '{
              "name": "snu-${{ needs.prepare.outputs.env_name }}",
              "project_id": "${{ steps.ci_outputs.outputs.project_id }}"
            }' \
            "${{ env.scw_endpoint }}/regions/${{ steps.ci_outputs.outputs.region }}/secrets" | jq -r ".id" )
          echo "$secret_id"
          echo "secret_id=$secret_id" >> $GITHUB_OUTPUT
          echo "Retreive ci secret latest revision"
          data=$(curl -s -X GET \
            -H "X-Auth-Token: $SCW_SECRET_KEY" \
            "${{ env.scw_endpoint }}/regions/${{ steps.ci_outputs.outputs.region }}/secrets/${{ steps.ci_outputs.outputs.secret_id }}/versions/latest_enabled/access" | jq -r ".data")
          echo "Create a new revision for custom environment"
          curl -s -X POST \
            -H "X-Auth-Token: $SCW_SECRET_KEY" \
            -H "Content-Type: application/json" \
            -d "{\"data\":\"${data}\"}" \
            "${{ env.scw_endpoint }}/regions/${{ steps.ci_outputs.outputs.region }}/secrets/$secret_id/versions"

      - name: Import secret
        if: steps.check_secret.outputs.has_secret == '0'
        working-directory: ${{ env.custom_directory }}
        run: sed -i.bak "s|###___SECRET_ID___###|${{ steps.ci_outputs.outputs.region }}/${{ steps.create_secret.outputs.secret_id }}|g" imports.tf

      - name: Validate terraform
        working-directory: ${{ env.custom_directory }}
        run: terraform validate -no-color

      - name: Terraform auto-apply
        # add -lock-timeout option until https://github.com/hashicorp/terraform/issues/33217 is fixed
        working-directory: ${{ env.custom_directory }}
        run: |
          terraform apply -no-color -input=false -auto-approve -lock-timeout=15m \
            -var="api_image_tag=${{ needs.build_api.outputs.image_tag }}" \
            -var="admin_image_tag=${{ needs.build_app.outputs.image_tag }}" \
            -var="app_image_tag=${{ needs.build_admin.outputs.image_tag }}" \

      - name: Add comment to PR
        if: github.event_name == 'pull_request' && steps.check_secret.outputs.has_secret == '0'
        working-directory: ${{ env.custom_directory }}
        env:
          URL: ${{ github.event.pull_request.comments_url }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          api_endpoint=$(terraform output -raw api_endpoint)
          app_endpoint=$(terraform output -raw app_endpoint)
          admin_endpoint=$(terraform output -raw admin_endpoint)
          curl \
            -X POST \
            $URL \
            -H "Content-Type: application/json" \
            -H "Authorization: token $GITHUB_TOKEN" \
            --data "{ \"body\": \"Application endpoints :\n\n- $api_endpoint\n- $app_endpoint\n- $admin_endpoint\" }"
